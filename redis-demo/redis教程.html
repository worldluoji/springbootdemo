<!DOCTYPE html>
<html lang="en">
 <head> 
  <meta charset="UTF-8" /> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
  <title> redis教程 </title> 
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" /> 
  <meta name="description" content="" /> 
  <meta name="generator" content="GitBook 2.6.7" /> 
  <meta name="HandheldFriendly" content="true" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /> 
  <meta name="apple-mobile-web-app-capable" content="yes" /> 
  <meta name="apple-mobile-web-app-status-bar-style" content="black" /> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png" /> 
  <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon" /> 
 </head> 
 <body> 
  <div class="book" data-level="16" data-chapter-title="第十六章：redis教程" data-filepath="di-shi-sizhang-ff1a-redis-jiao-cheng.md" data-basepath="." data-revision="Sun Jun 24 2018 19:46:33 GMT+0800 (中国标准时间)" data-innerlanguage=""> 
   <div class="book-body"> 
    <div class="body-inner"> 
     <div class="book-header" role="navigation"> 
      <!-- Actions Left --> 
     </div> 
     <div class="page-wrapper" tabindex="-1" role="main"> 
      <div class="page-inner"> 
       <section class="normal" id="section-"> 
        <h1 id="redis教程：">redis教程：</h1> 
        <h2 id="概述">概述</h2> 
        <p><code>redis</code>是一种<code>nosql</code>数据库,他的数据是保存在内存中，同时<code>redis</code>可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比<code>memcached</code>支持更多的数据结构(<code>string</code>,<code>list列表[队列和栈]</code>,<code>set[集合]</code>,<code>sorted set[有序集合]</code>,<code>hash(hash表)</code>)。相关参考文档：<a href="http://redisdoc.com/index.html" target="_blank">http://redisdoc.com/index.html</a></p> 
        <h2 id="redis使用场景：">redis使用场景：</h2> 
        <ol> 
         <li>登录会话存储：存储在<code>redis</code>中，与<code>memcached</code>相比，数据不会丢失。</li> 
         <li>排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。</li> 
         <li>作为消息队列：比如<code>celery</code>就是使用<code>redis</code>作为中间人。</li> 
         <li>当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。</li> 
         <li>一些常用的数据缓存：比如我们的<code>BBS</code>论坛，板块不会经常变化的，但是每次访问首页都要从<code>mysql</code>中获取，可以在<code>redis</code>中缓存起来，不用每次请求数据库。</li> 
         <li>把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。</li> 
         <li>好友关系：微博的好友关系使用<code>redis</code>实现。</li> 
         <li>发布和订阅功能：可以用来做聊天软件。</li> 
        </ol> 
        <h2 id="redis和memcached的比较："><code>redis</code>和<code>memcached</code>的比较：</h2> 
        <table> 
         <thead> 
          <tr> 
           <th></th> 
           <th>memcached</th> 
           <th>redis</th> 
          </tr> 
         </thead> 
         <tbody> 
          <tr> 
           <td>类型</td> 
           <td>纯内存数据库</td> 
           <td>内存磁盘同步数据库</td> 
          </tr> 
          <tr> 
           <td>数据类型</td> 
           <td>在定义value时就要固定数据类型</td> 
           <td>不需要</td> 
          </tr> 
          <tr> 
           <td>虚拟内存</td> 
           <td>不支持</td> 
           <td>支持</td> 
          </tr> 
          <tr> 
           <td>过期策略</td> 
           <td>支持</td> 
           <td>支持</td> 
          </tr> 
          <tr> 
           <td>存储数据安全</td> 
           <td>不支持</td> 
           <td>可以将数据同步到dump.db中</td> 
          </tr> 
          <tr> 
           <td>灾难恢复</td> 
           <td>不支持</td> 
           <td>可以将磁盘中的数据恢复到内存中</td> 
          </tr> 
          <tr> 
           <td>分布式</td> 
           <td>支持</td> 
           <td>主从同步</td> 
          </tr> 
          <tr> 
           <td>订阅与发布</td> 
           <td>不支持</td> 
           <td>支持</td> 
          </tr> 
         </tbody> 
        </table> 
        <h2 id="redis在ubuntu系统中的安装与启动"><code>redis</code>在<code>ubuntu</code>系统中的安装与启动</h2> 
        <ol> 
         <li>安装：<pre><code> sudo apt-get install redis-server
</code></pre></li> 
         <li>卸载：<pre><code> sudo apt-get purge --auto-remove redis-server
</code></pre></li> 
         <li><p>启动：<code>redis</code>安装后，默认会自动启动，可以通过以下命令查看：</p> <pre><code> ps aux|grep redis
</code></pre><p>如果想自己手动启动，可以通过以下命令进行启动：</p> <pre><code> sudo service redis-server start
</code></pre></li> 
         <li><p>停止：</p> <pre><code> sudo service redis-server stop
</code></pre></li> 
        </ol> 
        <h2 id="对redis的操作">对<code>redis</code>的操作</h2> 
        <p>对<code>redis</code>的操作可以用两种方式，第一种方式采用<code>redis-cli</code>，第二种方式采用编程语言，比如<code>Python</code>、<code>PHP</code>和<code>JAVA</code>等。 </p> 
        <ol> 
         <li><p>使用<code>redis-cli</code>对<code>redis</code>进行字符串操作：</p> </li> 
         <li><p>启动<code>redis</code>：</p> <pre><code>  sudo service redis-server start
</code></pre></li> 
         <li>连接上<code>redis-server</code>：<pre><code>  redis-cli -h [ip] -p [端口]
</code></pre></li> 
         <li><p>添加：</p> <pre><code>  set key value
  如：
  set username xiaotuo
</code></pre><p>将字符串值<code>value</code>关联到<code>key</code>。如果<code>key</code>已经持有其他值，<code>set</code>命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。</p> </li> 
         <li><p>删除：</p> <pre><code>  del key
  如：
  del username
</code></pre></li> 
         <li><p>设置过期时间：</p> <pre><code>  expire key timeout(单位为秒)
</code></pre><p>也可以在设置值的时候，一同指定过期时间：</p> <pre><code>  set key value EX timeout
  或：
  setex key timeout value
</code></pre></li> 
         <li><p>查看过期时间：</p> <pre><code>  ttl key
  如：
  ttl username
</code></pre></li> 
         <li><p>查看当前<code>redis</code>中的所有<code>key</code>：</p> <pre><code>  keys *
</code></pre></li> 
         <li><p>列表操作：</p> 
          <ul> 
           <li><p>在列表左边添加元素：</p> <pre><code>  lpush key value
</code></pre><p>将值<code>value</code>插入到列表<code>key</code>的表头。如果<code>key</code>不存在，一个空列表会被创建并执行<code>lpush</code>操作。当<code>key</code>存在但不是列表类型时，将返回一个错误。</p> </li> 
           <li><p>在列表右边添加元素：</p> <pre><code>  rpush key value
</code></pre><p>将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误。</p> </li> 
           <li><p>查看列表中的元素：</p> <pre><code>  lrange key start stop
</code></pre><p>返回列表<code>key</code>中指定区间内的元素，区间以偏移量<code>start</code>和<code>stop</code>指定,如果要左边的第一个到最后的一个<code>lrange key 0 -1</code>。</p> </li> 
           <li><p>移除列表中的元素：</p> 
            <ul> 
             <li>移除并返回列表<code>key</code>的头元素：<pre><code>  lpop key
</code></pre></li> 
             <li>移除并返回列表的尾元素：<pre><code>rpop key
</code></pre></li> 
             <li><p>移除并返回列表<code>key</code>的中间元素：</p> <pre><code>  lrem key count value
</code></pre><p>将删除<code>key</code>这个列表中，<code>count</code>个值为<code>value</code>的元素。</p> </li> 
            </ul> </li> 
           <li><p>指定返回第几个元素：</p> <pre><code>  lindex key index
</code></pre><p>将返回<code>key</code>这个列表中，索引为<code>index</code>的这个元素。</p> </li> 
           <li><p>获取列表中的元素个数：</p> <pre><code>  llen key
  如：
  llen languages
</code></pre></li> 
           <li><p>删除指定的元素：</p> <pre><code>  lrem key count value
  如：
  lrem languages 0 php
</code></pre><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。<code>count</code>的值可以是以下几种：</p> 
            <ul> 
             <li>count &gt; 0：从表头开始向表尾搜索，移除与<code>value</code>相等的元素，数量为<code>count</code>。</li> 
             <li>count &lt; 0：从表尾开始向表头搜索，移除与 <code>value</code>相等的元素，数量为<code>count</code>的绝对值。</li> 
             <li>count = 0：移除表中所有与<code>value</code> 相等的值。</li> 
            </ul> </li> 
          </ul> </li> 
         <li><p><code>set</code>集合的操作：</p> 
          <ul> 
           <li>添加元素：<pre><code>  sadd set value1 value2....
  如：
  sadd team xiaotuo datuo
</code></pre></li> 
           <li>查看元素：<pre><code>  smembeers set
  如：
  smembers team
</code></pre></li> 
           <li>移除元素：<pre><code>  srem set member...
  如：
  srem team xiaotuo datuo
</code></pre></li> 
           <li>查看集合中的元素个数：<pre><code>  scard set
  如：
  scard team1
</code></pre></li> 
           <li>获取多个集合的交集：<pre><code>  sinter set1 set2
  如：
  sinter team1 team2
</code></pre></li> 
           <li>获取多个集合的并集：<pre><code>  sunion set1 set2
  如：
  sunion team1 team2
</code></pre></li> 
           <li>获取多个集合的差集：<pre><code>sdiff set1 set2
如：
sdiff team1 team2
</code></pre></li> 
          </ul> </li> 
         <li><p><code>hash</code>哈希操作：</p> 
          <ul> 
           <li><p>添加一个新值：</p> <pre><code>  hset key field value
  如：
  hset website baidu baidu.com
</code></pre><p>将哈希表<code>key</code>中的域<code>field</code>的值设为<code>value</code>。<br /> 如果<code>key</code>不存在，一个新的哈希表被创建并进行 <code>HSET</code>操作。如果域 <code>field</code>已经存在于哈希表中，旧值将被覆盖。</p> </li> 
           <li><p>获取哈希中的<code>field</code>对应的值：</p> <pre><code>  hget key field
  如：
  hget website baidu
</code></pre></li> 
           <li><p>删除<code>field</code>中的某个<code>field</code>：</p> <pre><code>  hdel key field
  如：
  hdel website baidu
</code></pre></li> 
           <li><p>获取某个哈希中所有的<code>field</code>和<code>value</code>：</p> <pre><code>  hgetall key
  如：
  hgetall website
</code></pre></li> 
           <li><p>获取某个哈希中所有的<code>field</code>：</p> <pre><code>  hkeys key
  如：
  hkeys website
</code></pre></li> 
           <li><p>获取某个哈希中所有的值：</p> <pre><code>hvals key
如：
hvals website
</code></pre></li> 
           <li><p>判断哈希中是否存在某个<code>field</code>：</p> <pre><code>hexists key field
如：
hexists website baidu
</code></pre></li> 
           <li><p>获取哈希中总共的键值对：</p> <pre><code>hlen field
如：
hlen website
</code></pre></li> 
          </ul> </li> 
         <li><p>事务操作：Redis事务可以一次执行多个命令，事务具有以下特征：</p> 
          <ul> 
           <li>隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰。</li> 
           <li>原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li> 
           <li><p>开启一个事务：</p> <pre><code>  multi
</code></pre><p>以后执行的所有命令，都在这个事务中执行的。</p> </li> 
           <li><p>执行事务：</p> <pre><code>  exec
</code></pre><p>会将在<code>multi</code>和<code>exec</code>中的操作一并提交。</p> </li> 
           <li><p>取消事务：</p> <pre><code>  discard
</code></pre><p>会将<code>multi</code>后的所有命令取消。</p> </li> 
           <li><p>监视一个或者多个<code>key</code>：</p> <pre><code>  watch key...
</code></pre><p>监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</p> </li> 
           <li><p>取消所有<code>key</code>的监视：</p> <pre><code>  unwatch
</code></pre></li> 
          </ul> </li> 
         <li><p>发布/订阅操作：</p> 
          <ul> 
           <li>给某个频道发布消息：<pre><code>  publish channel message
</code></pre></li> 
           <li>订阅某个频道的消息：<pre><code>  subscribe channel
</code></pre></li> 
          </ul> </li> 
         <li><p>持久化：<code>redis</code>提供了两种数据备份方式，一种是<code>RDB</code>，另外一种是<code>AOF</code>，以下将详细介绍这两种备份策略：</p> <p>| | RDB | AOF | | --- | --- | --- | | 开启关闭 | 开启：默认开启。关闭：把配置文件中所有的save都注释，就是关闭了。 | 开启：在配置文件中<code>appendonly yes</code>即开启了<code>aof</code>，为<code>no</code>关闭。 | | 同步机制 | 可以指定某个时间内发生多少个命令进行同步。比如1分钟内发生了2次命令，就做一次同步。 | 每秒同步或者每次发生命令后同步 | | 存储内容 | 存储的是redis里面的具体的值 | 存储的是执行的更新数据的操作命令 | | 存储文件的路径 | 根据dir以及dbfilename来指定路径和具体的文件名 | 根据dir以及appendfilename来指定具体的路径和文件名 | | 优点 | （1）存储数据到文件中会进行压缩，文件体积比aof小。（2）因为存储的是redis具体的值，并且会经过压缩，因此在恢复的时候速度比AOF快。（3）非常适用于备份。 | （1）AOF的策略是每秒钟或者每次发生写操作的时候都会同步，因此即使服务器故障，最多只会丢失1秒的数据。 （2）AOF存储的是Redis命令，并且是直接追加到aof文件后面，因此每次备份的时候只要添加新的数据进去就可以了。（3）如果AOF文件比较大了，那么Redis会进行重写，只保留最小的命令集合。 | | 缺点 | （1）RDB在多少时间内发生了多少写操作的时候就会出发同步机制，因为采用压缩机制，RDB在同步的时候都重新保存整个Redis中的数据，因此你一般会设置在最少5分钟才保存一次数据。在这种情况下，一旦服务器故障，会造成5分钟的数据丢失。（2）在数据保存进RDB的时候，Redis会fork出一个子进程用来同步，在数据量比较大的时候，可能会非常耗时。 | （1）AOF文件因为没有压缩，因此体积比RDB大。 （2）AOF是在每秒或者每次写操作都进行备份，因此如果并发量比较大，效率可能有点慢。（3）AOF文件因为存储的是命令，因此在灾难恢复的时候Redis会重新运行AOF中的命令，速度不及RDB。 | | 更多 | <a href="http://redisdoc.com/topic/persistence.html#redis" target="_blank">http://redisdoc.com/topic/persistence.html#redis</a> | |</p> </li> 
         <li><p>安全：在配置文件中，设置<code>requirepass password</code>，那么客户端连接的时候，需要使用密码：</p> <pre><code> &gt; redis-cli -p 127.0.0.1 -p 6379
 redis&gt; set username xxx
 (error) NOAUTH Authentication required.
 redis&gt; auth password
 redis&gt; set username xxx
 OK
</code></pre></li> 
        </ol> 
        <h3 id="python操作redis">Python操作redis</h3> 
        <ol> 
         <li><p>安装<code>python-redis</code>：</p> <pre><code class="lang-shell"> pip install redis
</code></pre> </li> 
         <li><p>新建一个文件比如<code>redis_test.py</code>，然后初始化一个<code>redis</code>实例变量，并且在<code>ubuntu</code>虚拟机中开启<code>redis</code>。比如虚拟机的<code>ip</code>地址为<code>192.168.174.130</code>。示例代码如下：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 从redis包中导入Redis类</span>
 <span class="hljs-keyword">from</span> redis <span class="hljs-keyword">import</span> Redis
 <span class="hljs-comment"># 初始化redis实例变量</span>
 xtredis = Redis(host=<span class="hljs-string">'192.168.174.130'</span>,port=<span class="hljs-number">6379</span>)
</code></pre> </li> 
         <li><p>对字符串的操作：操作<code>redis</code>的方法名称，跟之前使用<code>redis-cli</code>一样，现就一些常用的来做个简单介绍，示例代码如下(承接以上的代码)：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期</span>
 xtredis.set(<span class="hljs-string">'username'</span>,<span class="hljs-string">'xiaotuo'</span>,ex=<span class="hljs-number">60</span>)
 <span class="hljs-comment"># 获取一个值</span>
 xtredis.get(<span class="hljs-string">'username'</span>)
 <span class="hljs-comment"># 删除一个值</span>
 xtredis.delete(<span class="hljs-string">'username'</span>)
 <span class="hljs-comment"># 给某个值自增1</span>
 xtredis.set(<span class="hljs-string">'read_count'</span>,<span class="hljs-number">1</span>)
 xtredis.incr(<span class="hljs-string">'read_count'</span>)  <span class="hljs-comment"># 这时候read_count变为2</span>
 <span class="hljs-comment"># 给某个值减少1</span>
 xtredis.decr(<span class="hljs-string">'read_count'</span>) <span class="hljs-comment"># 这时候read_count变为1</span>
</code></pre> </li> 
         <li><p>对列表的操作：同字符串操作，所有方法的名称跟使用<code>redis-cli</code>操作是一样的：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 给languages这个列表往左边添加一个python</span>
 xtredis.lpush(<span class="hljs-string">'languages'</span>,<span class="hljs-string">'python'</span>)
 <span class="hljs-comment"># 给languages这个列表往左边添加一个php</span>
 xtredis.lpush(<span class="hljs-string">'languages'</span>,<span class="hljs-string">'php'</span>)
 <span class="hljs-comment"># 给languages这个列表往左边添加一个javascript</span>
 xtredis.lpush(<span class="hljs-string">'languages'</span>,<span class="hljs-string">'javascript'</span>)

 <span class="hljs-comment"># 获取languages这个列表中的所有值</span>
 <span class="hljs-keyword">print</span> xtredis.lrange(<span class="hljs-string">'languages'</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)
 &gt; [<span class="hljs-string">'javascript'</span>,<span class="hljs-string">'php'</span>,<span class="hljs-string">'python'</span>]
</code></pre> </li> 
         <li><p>对集合的操作：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 给集合team添加一个元素xiaotuo</span>
 xtredis.sadd(<span class="hljs-string">'team'</span>,<span class="hljs-string">'xiaotuo'</span>)
 <span class="hljs-comment"># 给集合team添加一个元素datuo</span>
 xtredis.sadd(<span class="hljs-string">'team'</span>,<span class="hljs-string">'datuo'</span>)
 <span class="hljs-comment"># 给集合team添加一个元素slice</span>
 xtredis.sadd(<span class="hljs-string">'team'</span>,<span class="hljs-string">'slice'</span>)

 <span class="hljs-comment"># 获取集合中的所有元素</span>
 xtredis.smembers(<span class="hljs-string">'team'</span>)
 &gt; [<span class="hljs-string">'datuo'</span>,<span class="hljs-string">'xiaotuo'</span>,<span class="hljs-string">'slice'</span>] <span class="hljs-comment"># 无序的</span>
</code></pre> </li> 
         <li><p>对哈希(<code>hash</code>)的操作：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 给website这个哈希中添加baidu</span>
 xtredis.hset(<span class="hljs-string">'website'</span>,<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'baidu.com'</span>)
 <span class="hljs-comment"># 给website这个哈希中添加google</span>
 xtredis.hset(<span class="hljs-string">'website'</span>,<span class="hljs-string">'google'</span>,<span class="hljs-string">'google.com'</span>)

 <span class="hljs-comment"># 获取website这个哈希中的所有值</span>
 <span class="hljs-keyword">print</span> xtredis.hgetall(<span class="hljs-string">'website'</span>)
 &gt; {<span class="hljs-string">&quot;baidu&quot;</span>:<span class="hljs-string">&quot;baidu.com&quot;</span>,<span class="hljs-string">&quot;google&quot;</span>:<span class="hljs-string">&quot;google.com&quot;</span>}
</code></pre> </li> 
         <li><p>事务(管道)操作：<code>redis</code>支持事务操作，也即一些操作只有统一完成，才能算完成。否则都执行失败，用<code>python</code>操作<code>redis</code>也是非常简单，示例代码如下：</p> <pre><code class="lang-python"> <span class="hljs-comment"># 定义一个管道实例</span>
 pip = xtredis.pipeline()
 <span class="hljs-comment"># 做第一步操作，给BankA自增长1</span>
 pip.incr(<span class="hljs-string">'BankA'</span>)
 <span class="hljs-comment"># 做第二步操作，给BankB自减少1</span>
 pip.desc(<span class="hljs-string">'BankB'</span>)
 <span class="hljs-comment"># 执行事务</span>
 pip.execute()
</code></pre> </li> 
        </ol> 
        <p>以上便展示了<code>python-redis</code>的一些常用方法，如果想深入了解其他的方法，可以参考<code>python-redis</code>的源代码（查看源代码<code>pycharm</code>快捷键提示：把鼠标光标放在<code>import Redis</code>的<code>Redis</code>上，然后按<code>ctrl+b</code>即可进入）。</p> 
       </section> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>   
 </body>
</html>