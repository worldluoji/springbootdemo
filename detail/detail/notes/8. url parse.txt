1. url路径匹配
结合PathVariableController
AbstractHandlerMethodMapping#lookupHandlerMethod
->
@Nullable
protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {
   List<Match> matches = new ArrayList<>();
   // 尝试按照 URL 进行精准匹配
   List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);
   if (directPathMatches != null) {
      // 精确匹配上，存储匹配结果
      addMatchingMappings(directPathMatches, matches, request);
   }
   if (matches.isEmpty()) {
      // 没有精确匹配上，尝试根据请求来进行模糊匹配
      addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);
   }

   if (!matches.isEmpty()) {
      Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));
      matches.sort(comparator);
      Match bestMatch = matches.get(0);
      if (matches.size() > 1) {
         //处理多个匹配的情况
      }
      //省略其他非关键代码
      return bestMatch.handlerMethod;
   } else {
      //匹配不上，直接报错
      return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);
   }
}

对于@GetMapping(path = "/hello1/{name}")，
http://localhost:8080/hi1/xiao/ming  无法精确匹配，
于是进入了模糊匹配的分支->
RequestMappingInfo#getMatchingCondition

public RequestMappingInfo getMatchingCondition(HttpServletRequest request) {
    RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);
    if (methods == null) {
       return null;
    }
    ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);
    if (params == null) {
       return null;
    }
    //省略其他匹配条件
    PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);
    if (patterns == null) {
       return null;
    }
    //省略其他匹配条件
    return new RequestMappingInfo(this.name, patterns,
          methods, params, headers, consumes, produces, custom.getCondition());
 }

匹配会查询所有的信息，例如 Header、Body 类型以及 URL 等。如果有一项不符合条件，则不匹配。
当使用 http://localhost:8080/hi1/xiaoming 访问时，其中 patternsCondition 是可以匹配上的。
实际的匹配方法执行是通过 AntPathMatcher#match 来执行,
而http://localhost:8080/hi1/xiao/ming  无法匹配，因此报错。

http://localhost:8080/hi1/xiaoming/ 为什么多一个"/"不会报错：

private String getMatchingPattern(String pattern, String lookupPath) {
    //省略其他非关键代码
    if (this.pathMatcher.match(pattern, lookupPath)) {
       return pattern;
    }
    //尝试加一个/来匹配
    if (this.useTrailingSlashMatch) {
       if (!pattern.endsWith("/") && this.pathMatcher.match(pattern + "/", lookupPath)) {
          return pattern + "/";
       }
    }
    return null;
}
在 useTrailingSlashMatch 这个参数启用时（默认启用），会把 Pattern 结尾加上 / 再尝试匹配一次。
如果能匹配上，在最终返回 Pattern 时就隐式自动加 /。


2. Spring解析请求参数名称的过程
例子：UrlParseController

假设maven关闭了选项：
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
   <configuration>
        <debug>false</debug>
        <parameters>false</parameters>
    </configuration>
</plugin>
这 2 个参数控制了一些 debug 信息是否加进 class 文件中。我们可以开启这两个参数来编译，
然后使用下面的命令来查看信息：javap -verbose UrlParseController.class :
Code:
stack=1, locals=2, args_size=2
   0: aload_1
   1: areturn
LineNumberTable:
  line 11: 0
LocalVariableTable:
  Start  Length  Slot  Name   Signature
      0       2     0  this   Lcom/example/detail/controllers/UrlParseController;
      0       2     1  name   Ljava/lang/String;
MethodParameters:
Name                           Flags
name
这时候我们可以看到有name这个参数信息，而关闭上述两个maven参数后，就没有name参数信息了。
这时候如果不显示指定，spring自然无法获取，就会报错。

AbstractNamedValueMethodArgumentResolver#updateNamedValueInfo:
 
private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {
    String name = info.name;
    if (info.name.isEmpty()) {
       name = parameter.getParameterName();
       if (name == null) {
          throw new IllegalArgumentException(
                "Name for argument type [" + parameter.getNestedParameterType().getName() +
                "] not available, and parameter name information not found in class file either.");
       }
    }
    String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);
    return new NamedValueInfo(name, info.required, defaultValue);
 }

 其中 NamedValueInfo 的 name 为 @RequestParam 指定的值。
 当参数名不存在，@RequestParam 也没有指明，自然就无法决定到底要用什么名称去获取请求参数。
 所以强烈建议显示指定参数名字。
 另外需要注意的是，本案例围绕的都是 @RequestParam，但 @PathVarible 也有一样的问题。