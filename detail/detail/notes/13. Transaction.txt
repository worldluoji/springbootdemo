1. Spring 处理事务的时候，如果没有在 @Transactional 中配置 rollback 属性，
那么只有捕获到 RuntimeException 或者 Error 的时候才会触发回滚操作。
前置知识：
1）Spring 在初始化时，会通过扫描拦截对事务的方法进行增强。
如果目标方法存在事务，Spring 就会创建一个 Bean 对应的代理（Proxy）对象，并进行相关的事务处理操作。
2）事务本质上也是一种特殊的切面，在创建的过程中，被 CglibAopProxy 代理。
事务处理的拦截器是 TransactionInterceptor。
3）TransactionInterceptor 继承类 TransactionAspectSupport，实现了接口 MethodInterceptor。
当执行代理类的目标方法时，会触发 invoke()。
当它 catch 到异常时，会调用 completeTransactionAfterThrowing 方法做进一步处理：

protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
    final InvocationCallback invocation) throws Throwable {
    //省略非关键代码
    Object retVal;
    try {
       retVal = invocation.proceedWithInvocation();
    }
    catch (Throwable ex) {
       completeTransactionAfterThrowing(txInfo, ex);
       throw ex;
    }
    finally {
       cleanupTransactionInfo(txInfo);
    }
    //省略非关键代码
}

->completeTransactionAfterThrowing


protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
    //省略非关键代码
    //判断是否需要回滚
    if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {
       try {
          //执行回滚
          txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
       }
       catch (TransactionSystemException ex2) {
          ex2.initApplicationException(ex);
          throw ex2;
       }
       catch (RuntimeException | Error ex2) {
          throw ex2;
       }
    }
    //省略非关键代码
}

->
public boolean rollbackOn(Throwable ex) {
    // 层级 1：根据"rollbackRules"及当前捕获异常来判断是否需要回滚
    RollbackRuleAttribute winner = null;
    int deepest = Integer.MAX_VALUE;
    if (this.rollbackRules != null) {
       for (RollbackRuleAttribute rule : this.rollbackRules) {
          // 当前捕获的异常可能是回滚“异常”的继承体系中的“一员”
          int depth = rule.getDepth(ex);
          if (depth >= 0 && depth < deepest) {
             deepest = depth;
             winner = rule;
          }
       }
    }
    // 层级 2：调用父类的 rollbackOn 方法来决策是否需要 rollback
    if (winner == null) {
       return super.rollbackOn(ex);
    }
    return !(winner instanceof NoRollbackRuleAttribute);
 }

 从代码可以看出，如果没有在 @Transactional 中配置 rollback 属性，或是捕获到的异常和所配置异常的类型不一致，
 就会继续调用父类的 rollbackOn() 进行处理。
 ->super.rollbackOn
 public boolean rollbackOn(Throwable ex) {
    return (ex instanceof RuntimeException || ex instanceof Error);
 }
 这就解释了为什么不显示指定抛出异常回滚时，只有RuntimeException和Error才会回滚。
 要想其它异常时回滚，则显示指定即可：
@Transactional(rollbackFor = Exception.class)
同理，如果要RuntimeException不回滚，但其它异常回滚：
@Transactional(rollbackFor = Exception.class, noRollbackFor = RuntimeException.class)


2. private添加@Transactional注解，事务无效

Bean 初始化之后，开始尝试代理操作，这个过程是从 AbstractAutoProxyCreator 里的
postProcessAfterInitialization 方法开始处理：

public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
       Object cacheKey = getCacheKey(bean.getClass(), beanName);
       if (this.earlyProxyReferences.remove(cacheKey) != bean) {
          return wrapIfNecessary(bean, beanName, cacheKey);
       }
    }
    return bean;
 }

一路往下找到AopUtils#canApply：
public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
    //省略非关键代码
    for (Class<?> clazz : classes) {
       Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
       for (Method method : methods) {
          if (introductionAwareMethodMatcher != null ?
                introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
                methodMatcher.matches(method, targetClass)) {
             return true;
          }
       }
    }
    return false;
 }
 这个方法就是针对切面定义里的条件，确定这个方法是否可以被应用创建成代理。
 其中有一段 methodMatcher.matches(method, targetClass) 是用来判断这个方法是否符合条件。

-> 
public boolean matches(Method method, Class<?> targetClass) {
    //省略非关键代码
    TransactionAttributeSource tas = getTransactionAttributeSource();
    return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
}

->
public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
    //省略非关键代码
    TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
    //省略非关键代码
 }
}

->关键：
protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
    //省略非关键代码
    if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
       return null;
    }
    //省略非关键代码
}

1) allowPublicMethodsOnly()
->
protected boolean allowPublicMethodsOnly() {
    return this.publicMethodsOnly;
}
这个 publicMethodsOnly 属性是通过 AnnotationTransactionAttributeSource 的构造方法初始化的，默认为 true:
public AnnotationTransactionAttributeSource() {
    this(true);
}

2) isPublic
对应的几类修饰符分别是：PUBLIC: 1，PRIVATE: 2，PROTECTED: 4
public static boolean isPublic(int mod) {
    return (mod & PUBLIC) != 0;
}

这就解释了，只有当注解为事务的方法被声明为 public 的时候，才会被 Spring 处理。